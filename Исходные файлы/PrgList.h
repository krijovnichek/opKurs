#ifndef PRGLIST_H_INCLUDED
#define PRGLIST_H_INCLUDED

#include <iostream>
#include <cassert>
#include <fstream>

namespace MyList
{

template <typename T> class MY_list;
template <typename T> class ListIterator;

/*----------------------------------------------------------------------------*/
template <typename T> class Node
    {
    friend class MY_list<T>;
    friend class ListIterator <T>;

    private:
        T data;
        Node* next;

    public:
        Node(T d, Node* n = NULL) : data(d), next(n) {}
    };
/*----------------------------------------------------------------------------*/
template <typename T> class MY_list
{
private:
    Node<T>* head;
    Node<T>* tail;
    int count;
public:
    typedef ListIterator<T> iterator;
/*----------------------------------------------------------------------------*/
    void clear();
/*----------------------------------------------------------------------------*/
     int GetCount();
/*----------------------------------------------------------------------------*/
     bool empty();
/*----------------------------------------------------------------------------*/
      ListIterator<T> begin()
    {return ListIterator<T>(head);}
/*----------------------------------------------------------------------------*/
    ListIterator<T> end()
    {return ListIterator<T>(tail);}
/*----------------------------------------------------------------------------*/
    MY_list(const MY_list<T> &object );
/*----------------------------------------------------------------------------*/
    ~MY_list();
/*----------------------------------------------------------------------------*/
     MY_list() : head(NULL), tail(NULL), count(0) {}
/*----------------------------------------------------------------------------*/
    void addLast(T);
/*----------------------------------------------------------------------------*/
    void delFirst();
/*----------------------------------------------------------------------------*/
    void delLast();
/*----------------------------------------------------------------------------*/
    void Print();
/*----------------------------------------------------------------------------*/
    int Load_List_Train(MY_list<T> &object);
/*----------------------------------------------------------------------------*/
    int Load_List_Bus(MY_list<T> &object);
/*----------------------------------------------------------------------------*/
    int Load_List_Airship(MY_list<T> &object);
/*----------------------------------------------------------------------------*/
    int Load_List_Plane(MY_list<T> &object);
/*----------------------------------------------------------------------------*/
    void Save_List_Train(MY_list<T> object);
/*----------------------------------------------------------------------------*/
    void Save_List_Bus(MY_list<T> object);
/*----------------------------------------------------------------------------*/
    void Save_List_Airship(MY_list<T> object);
/*----------------------------------------------------------------------------*/
    void Save_List_Plane(MY_list<T> object);
/*----------------------------------------------------------------------------*/

};

/*----------------------------------------------------------------------------*/
template <typename T> class ListIterator
{
private:
    Node<T> *target;
public:
    ListIterator() {}
/*----------------------------------------------------------------------------*/
    ListIterator(Node<T> *target) : target(target) {}
/*----------------------------------------------------------------------------*/
    T& operator*()
        {return target->data;}
/*----------------------------------------------------------------------------*/
     T* operator->()
        {return &target->data;}
/*----------------------------------------------------------------------------*/
    ListIterator& operator++()
    {
        target = target->next;
        return *this;
    }
/*----------------------------------------------------------------------------*/
    ListIterator operator++(int)
    {
        target = target->next;
        return *this;
    }
/*----------------------------------------------------------------------------*/
    bool operator==(ListIterator const& r)
        {return (target == r.target);}
/*----------------------------------------------------------------------------*/
    bool operator!=(ListIterator const& r)
        {return (target != r.target);}
/*----------------------------------------------------------------------------*/
};

}

#endif // PRGLIST_H_INCLUDED
